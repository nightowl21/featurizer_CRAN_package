% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/par_sapply.R
\name{par_sapply}
\alias{par_sapply}
\title{A friendlier parSapply.}
\usage{
par_sapply(X, FUNC, detect_cores)
}
\arguments{
\item{X}{The vector of value to perform paralleized sapply on.}

\item{FUNC}{Function to be applied to every value of X, similar to sapply}

\item{detect_cores}{If False (default), 2 cores are used. If True, half the number of cores are used on Mac OS else 2 cores are used.}
}
\value{
The a vector just like sapply. It does applies the function on X in parallel and hence is very fast.
}
\description{
A sleek wrapper on the function parSapply. This function does not require user to allocate clusters and then stop them. This function uses parSapply across half the available cores and after the computation is done, it stops the clusters as well. The inputs are same os parSapply from parallel package
}
\examples{
par_sapply(1:100, function(x) x*100)
}
